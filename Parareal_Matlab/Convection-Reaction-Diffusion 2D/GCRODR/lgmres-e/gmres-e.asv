% Arnoldi Iteration
%
% Generates relation (I - z*z)A V(:,1:m) = V(:,1:m+1) H
%
% INPUT:  A      N-by-N matrix
%         X      current solution vector
%         R0      N-by-1 preconditioned residual vector
%         M      number of GMRES iterations to perform
%         M1     left preconditioner for A
%         M2     right preconditioner for A
%         z      the approximate error 
%         tol    specifies the tolerance of the method
% OUTPUT: V      N-by-M+1 matrix containing orthogonal basis for Krylov subspace 
%         H      M+1-by-M upper Hessenburg reduction of matrix operator
%         B      the matrix C'*A*V(:,1:k)
%         K      number of GMRES iterations actually performed
%         RESVEC vector containing norm of residual at each iteration
%function [V,H,B,k,resvec] = gmres-e(A,x,r,m,M1,M2,c,u,tol)

if(isempty(M1))
   existM1 = 0;
else
   existM1 = 1;
end
if(isempty(M2))
   existM2 = 0;
else
   existM2 = 1;
end

% Initialize V
V(:,1) = r0 / norm(r0);

for k = 1:m
   % Find w using preconditioning if available.
   if(existM2)
      w = M2 \ V(:,k);
   else
      w = V(:,k);
   end
   w = A*w;
   if(existM1)
      w = M1 \ w;
   end

   % Create next column of V and H
   for j = 1:k
      H(j,k) = V(:,j)' * w;
      w = w - H(j,k) * V(:,j);
      hh=V(:,j)' * w;
      w=w-hh*V(:,j);
   end

   H(k+1,k) = norm(w);
   V(:,k+1) = w / H(k+1,k);

end
 rhs = zeros(k+1,1);
   rhs(1) = norm(r0);
  y = H \ rhs;
  res = rhs - H * y;
  resvec=norm(res);
% Calculate solution and residual.
z=V(:,1:m) * y;
x = x + z;
r = V * res;
delta=norm(r-r0);
c=r-r0/delta;
u=delta*z;



if(isempty(M1))
   existM1 = 0;
else
   existM1 = 1;
end
if(isempty(M2))
   existM2 = 0;
else
   existM2 = 1;
end
% Initialize V
res_norm=[];
res_norm=[res_norm resvec];
iter=1;
while resnorm<tol
    iter=iter+1;
beta= norm(r);
V(:,1) = r /beta;
for k = 1:m
   % Find w using preconditioning if available.
   if(existM2)
      w = M2 \ V(:,k);
   else
      w = V(:,k);
   end
   w = A*w;
   if(existM1)
      w = M1 \ w;
   end

   % Apply (I-C*C') operator to Aw
   B(:,k) = c' * w;
   w = w - c * B(:,k);

   % Create next column of V and H
   for j = 1:k
      H(j,k) = V(:,j)' * w;
      w = w - H(j,k) * V(:,j);
   end
   H(k+1,k) = norm(w);
   V(:,k+1) = w / H(k+1,k);
end
 for i = 1:k
      d(i) = norm(U(:,i));
      U(:,i) = U(:,i) / d(i);
   end
   D = diag(1 ./ d);

   % Form large H
   H2 = zeros(p+k+1,p+k);
   H2(1:k,1:k) = D;
   H2(1:k,k+1:p+k) = B;
   H2(k+1:p+k+1,k+1:p+k) = H;

   % Calculate solution update
   rhs = [c V]' * r;
   y = H2 \ rhs;
   x = x + [U V(:,1:p)] * y;

   % Calculate new residual
   r = r - [c V] * (H2 * y);
resnorm=norm(r);
res_norm=[res_norm resnorm];
end

